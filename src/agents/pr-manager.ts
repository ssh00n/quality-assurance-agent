/**
 * PR Manager Agent
 * Creates GitHub Pull Requests from code changes
 */

import { BaseAgent } from './base.js';
import { GitHubClient } from '../services/github-client.js';
import { logger } from '../utils/logger.js';
import {
  AgentConfig,
  AgentContext,
  CodeChanges,
  PullRequest,
  WorkflowPhase,
} from '../types/index.js';

/**
 * PR Manager input
 */
export interface PRManagerInput {
  codeChanges: CodeChanges;
}

/**
 * PR Manager Agent
 */
export class PRManagerAgent extends BaseAgent<PRManagerInput, PullRequest> {
  private githubClient: GitHubClient;
  private baseBranch: string;

  constructor(config: AgentConfig, context: AgentContext) {
    super(
      {
        ...config,
        agentType: 'pr-manager',
        timeout: config.timeout || 120000, // 2 minutes
      },
      context
    );

    // Initialize GitHub client
    const repoConfig = context.projectConfig?.github;
    this.githubClient = new GitHubClient(repoConfig?.owner, repoConfig?.repo);
    this.baseBranch = repoConfig?.baseBranch || process.env.GITHUB_DEFAULT_BRANCH || 'main';
  }

  /**
   * Run PR creation
   */
  protected async run(input?: PRManagerInput): Promise<PullRequest> {
    const codeChanges = input?.codeChanges || this.context.codeChanges;

    if (!codeChanges) {
      throw new Error('No code changes available for PR creation');
    }

    logger.agent('pr-manager', 'Starting PR creation', {
      qaId: this.context.qaItem.id,
      filesChanged: codeChanges.files.length,
    });

    this.updateProgress('Creating branch...', WorkflowPhase.PR_CREATION, 20);

    // Step 1: Create branch
    const branchName = this.generateBranchName();
    await this.createBranch(branchName);

    this.updateProgress('Committing changes...', WorkflowPhase.PR_CREATION, 50);

    // Step 2: Commit changes
    await this.commitChanges(branchName, codeChanges);

    this.updateProgress('Creating pull request...', WorkflowPhase.PR_CREATION, 80);

    // Step 3: Create PR
    const pr = await this.createPullRequest(branchName, codeChanges);

    this.updateProgress('PR created successfully', WorkflowPhase.PR_CREATION, 100);

    logger.agent('pr-manager', 'PR created successfully', {
      prNumber: pr.number,
      prUrl: pr.url,
    });

    return pr;
  }

  /**
   * Generate branch name
   */
  private generateBranchName(): string {
    const qaId = this.context.qaItem.id.substring(0, 8);
    const timestamp = Date.now().toString(36);
    const workType = this.context.decision?.workType || 'fix';

    return `qa-automation/${workType}-${qaId}-${timestamp}`;
  }

  /**
   * Create branch
   */
  private async createBranch(branchName: string): Promise<void> {
    // Get base branch SHA
    const baseSha = await this.githubClient.getMainSha(this.baseBranch);

    // Create new branch
    await this.githubClient.createBranch(branchName, baseSha);

    logger.info('Branch created', { branchName, baseBranch: this.baseBranch });
  }

  /**
   * Commit changes to branch
   */
  private async commitChanges(branchName: string, codeChanges: CodeChanges): Promise<void> {
    logger.info('Committing changes', {
      branch: branchName,
      fileCount: codeChanges.files.length,
    });

    for (const file of codeChanges.files) {
      const commitMessage = this.generateCommitMessage(file.path, file.description);

      if (file.changeType === 'deleted') {
        await this.githubClient.deleteFile(file.path, commitMessage, branchName);
      } else {
        await this.githubClient.createOrUpdateFile(file.path, file.content, commitMessage, branchName);
      }
    }

    logger.info('All changes committed', {
      filesCommitted: codeChanges.files.length,
    });
  }

  /**
   * Generate commit message
   */
  private generateCommitMessage(filePath: string, description: string): string {
    const prefix = this.getCommitPrefix();
    return `${prefix}: ${description}

File: ${filePath}

ü§ñ Generated by QA Automation Agent
QA Item: ${this.context.qaItem.url}`;
  }

  /**
   * Get commit prefix based on work type
   */
  private getCommitPrefix(): string {
    const workType = this.context.decision?.workType;

    switch (workType) {
      case 'bug_fix':
        return 'fix';
      case 'feature_add':
        return 'feat';
      case 'refactor':
        return 'refactor';
      case 'documentation':
        return 'docs';
      case 'test_addition':
        return 'test';
      default:
        return 'chore';
    }
  }

  /**
   * Create pull request
   */
  private async createPullRequest(branchName: string, codeChanges: CodeChanges): Promise<PullRequest> {
    const title = this.generatePRTitle();
    const body = this.generatePRBody(codeChanges);

    // Create PR
    const pr = await this.githubClient.createPullRequest(title, body, branchName, this.baseBranch);

    // Add labels
    const labels = this.generateLabels();
    if (labels.length > 0) {
      await this.githubClient.addLabels(pr.number, labels);
      pr.labels = labels;
    }

    return pr;
  }

  /**
   * Generate PR title
   */
  private generatePRTitle(): string {
    const qaTitle = this.context.qaItem.title;
    const prefix = this.getCommitPrefix();

    return `${prefix}: ${qaTitle}`;
  }

  /**
   * Generate PR body
   */
  private generatePRBody(codeChanges: CodeChanges): string {
    const analysis = this.context.analysis;
    const decision = this.context.decision;

    return `## ü§ñ Automated QA Fix

This PR was automatically generated to address: [${this.context.qaItem.title}](${this.context.qaItem.url})

### Issue Summary
${analysis?.summary || 'No summary available'}

### Work Type
- **Type:** ${decision?.workType || 'Unknown'}
- **Complexity:** ${decision?.estimatedComplexity || 'Unknown'}
- **Severity:** ${analysis?.severity || 'Unknown'}

### Changes Made
${codeChanges.files
  .filter((f) => f.changeType !== 'deleted')
  .map((f) => `- \`${f.path}\`: ${f.description}`)
  .join('\n')}

${
  codeChanges.files.some((f) => f.changeType === 'deleted')
    ? `### Files Deleted\n${codeChanges.files
        .filter((f) => f.changeType === 'deleted')
        .map((f) => `- \`${f.path}\``)
        .join('\n')}\n`
    : ''
}

### Test Results
- **Total Tests:** ${codeChanges.tests.total}
- **Passed:** ${codeChanges.tests.passed}
- **Failed:** ${codeChanges.tests.failed}
- **Coverage:** ${codeChanges.tests.coverage ? `${codeChanges.tests.coverage}%` : 'N/A'}

### Summary
${codeChanges.summary}

---

### ‚ö†Ô∏è Review Required
This PR was generated automatically. Please:
1. ‚úÖ Review all code changes carefully
2. ‚úÖ Run tests locally
3. ‚úÖ Verify the fix addresses the issue
4. ‚úÖ Check for any side effects

### Related Links
- **Notion QA:** ${this.context.qaItem.url}
- **Reporter:** ${this.context.qaItem.metadata.reporter}

---
*ü§ñ Generated by QA Automation Agent*
*Confidence: ${analysis?.confidence ? (analysis.confidence * 100).toFixed(0) : 'N/A'}%*
`;
  }

  /**
   * Generate PR labels
   */
  private generateLabels(): string[] {
    const labels: string[] = ['automated', 'qa-fix', 'needs-review'];

    const severity = this.context.analysis?.severity;
    if (severity === 'critical' || severity === 'high') {
      labels.push('priority-high');
    }

    const workType = this.context.decision?.workType;
    if (workType) {
      labels.push(workType);
    }

    return labels;
  }
}
